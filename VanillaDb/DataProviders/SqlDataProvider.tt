<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="VanillaDb" #>
<#@ import namespace="VanillaDb.Models" #>
// <copyright file="<#= GenerateName() #>.cs" company="<#= Table.Company #>">
// Copyright (c) <#= Table.Company #>. All rights reserved.
// </copyright>
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 4.7.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

namespace <#= Table.Namespace #>.<#= Table.TableAlias #>
{
    using System;
    using System.Collections.Generic;
    using System.Data;
    using System.Data.SqlClient;
    using System.Linq;
    using System.Threading.Tasks;
    using Microsoft.Extensions.Logging;
    using Microsoft.Extensions.Logging.Abstractions;

    /// <summary>SQL implementation of data provider interface for <#= Record #> data.</summary>
    /// <seealso cref="<#= Table.Namespace #>.<#= Table.TableAlias #>.I<#= Record #>DataProvider" />
    public partial class <#= GenerateName() #> : I<#= Record #>DataProvider
    {
        private ILogger Log { get; set; }

        /// <summary>Initializes a new instance of the <see cref="<#= GenerateName() #>"/> class.</summary>
        /// <param name="connectionString">The connection string.</param>
        /// <param name="logger">The logger for this instance.</param>
        public <#= GenerateName() #>(string connectionString, ILogger<<#= GenerateName() #>> logger)
        {
            this.Log = (ILogger)logger ?? NullLogger.Instance;
            this.ConnectionString = connectionString;
        }

        /// <summary>Gets or sets the connection string.</summary>
        /// <value>The connection string.</value>
        private string ConnectionString { get; set; }
<#
    // Generate the GetAll method if configured
    if (Table.Config.GetAll)
    {
#>

        /// <summary>Gets the data for all <#= Record #>(s) from the <#= Table.TableName #> table.</summary>
        /// <returns>Enumerable of <#= Record #> Data Model or null if not found.</returns>
        public async Task<IEnumerable<<#= Table.GetDataModelName() #>>> GetAll()
        {
            var <#= RecordCamel #>Data = new List<<#= Record #>DataModel>();
            using (var connection = new SqlConnection(this.ConnectionString))
            {
                var procName = "[<#= Table.Schema #>].[<#= Table.GetGetAllProcName() #>]";
                using (var command = new SqlCommand(procName))
                {
                    Log.LogInformation("Invoking Stored Procedure {0}.", procName);
                    command.CommandType = CommandType.StoredProcedure;
                    command.Connection = connection;

                    connection.Open();
                    var reader = await command.ExecuteReaderAsync();
                    if (reader.HasRows)
                    {
                        while (reader.Read())
                        {
                            var data = Parse<#= Record #>DataModel(reader);
                            <#= RecordCamel #>Data.Add(data);
                        }

                        // consume any trailing pieces
                        while (reader.NextResult()) {}
                    }
                }
            }

            return <#= RecordCamel #>Data;
        }
<#
    }
#>

<#
    // Generate the GetBy-Index and GetBy-Index-Bulk methods for each index
    foreach (IndexModel index in Indexes)
    {
#>
        /// <summary>Gets the data for the <#= Record #> with the given <#= index.ReadableFields() #>.</summary>
        <#= index.GetByIndexParamsXmlComments() #>
        /// <returns><#= Record #> Data Model or null if not found</returns>
        public async Task<<#= index.GetByIndexReturnType() #>> <#= index.GetByIndexMethodName() #>(<#= index.GetByIndexMethodParams() #>)
        {
<#
        foreach (FieldModel field in index.Fields.Where(f => !f.IsNullable))
        {
            if (field.FieldType.FieldType == typeof(string))
            {
#>
            if (string.IsNullOrWhiteSpace(<#= field.FieldName.ToCamelCase() #>))
            {
                throw new ArgumentNullException(nameof(<#= field.FieldName.ToCamelCase() #>));
            }

<#
            }
#>
<#
            if (field.IsIdentity && field.FieldType.FieldType == typeof(int))
            {
#>
            if (<#= field.FieldName.ToCamelCase() #> < 1)
            {
                throw new InvalidOperationException($"{<#= field.FieldName.ToCamelCase() #>} is not a valid <#= field.FieldName #>");
            }

<#
            }
        }
#>
            var <#= RecordCamel #>Data = new List<<#= Record #>DataModel>();
            using (var connection = new SqlConnection(this.ConnectionString))
            {
                var procName = "[<#= Table.Schema #>].[<#= GenerateGetByIndexStoredProcName(index) #>]";
                using (var command = new SqlCommand(procName))
                {
                    Log.LogInformation("Invoking Stored Procedure {0}.", procName);
                    command.CommandType = CommandType.StoredProcedure;
                    command.Connection = connection;
                    <#= GenerateGetByIndexAddParametersCode(index.Parameters()) #>

                    connection.Open();
                    var reader = await command.ExecuteReaderAsync();
                    if (reader.HasRows)
                    {
                        while (reader.Read())
                        {
                            var data = Parse<#= Record #>DataModel(reader);
                            <#= RecordCamel #>Data.Add(data);
                        }

                        // consume any trailing pieces
                        while (reader.NextResult()) {}
                    }
                }
            }

<#
            if (index.IsUnique)
            {
#>
            return <#= RecordCamel #>Data.FirstOrDefault();
<#
            }
            else
            {
#>
            return <#= RecordCamel #>Data;
<#
            }
#>
        }

        /// <summary>Gets the data for the <#= Record #>(s) with the given collection of <#= index.ReadableFields() #>.</summary>
        <#= index.BulkGetByIndexParamsXmlComments() #>
        /// <returns><#= Record #> Data Model or null if not found.</returns>
        public async Task<IEnumerable<<#= Record #>DataModel>> <#= index.GetByIndexMethodName() #>(<#= index.BulkGetByIndexMethodParams() #>)
        {
<#
        foreach (FieldModel field in index.Fields)
        {
#>
            if (<#= field.FieldName.ToCamelCase() #>s == null || !<#= field.FieldName.ToCamelCase() #>s.Any())
            {
                throw new ArgumentNullException(nameof(<#= field.FieldName.ToCamelCase() #>s));
            }

<#
        }
#>
            // Create an in-memory datatable with all of the field values
            var idDataTable = new DataTable();
            <#= GenerateInMemoryDataColumns(index.Fields) #>
            for (var i = 0; i < <#= index.Fields.ElementAt(0).FieldName.ToCamelCase() #>s.Count(); i++)
            {
                <#= GenerateInMemoryRowCreation(index.Fields) #>
            }

            var <#= RecordCamel #>Data = new List<<#= Record #>DataModel>();
            using (var connection = new SqlConnection(this.ConnectionString))
            {
                var procName = "[<#= Table.Schema #>].[<#= GenerateGetByIndexBulkStoredProcName(index) #>]";
                using (var command = new SqlCommand(procName))
                {
                    Log.LogInformation("Invoking Stored Procedure {0}.", procName);
                    command.CommandType = CommandType.StoredProcedure;
                    command.Connection = connection;

                    // Create the Stored Procedure Parameter and set to Type_IdTable
                    var idsParam = command.Parameters.AddWithValue("<#= GenerateBulkProcParameter(index) #>", idDataTable);
                    idsParam.SqlDbType = SqlDbType.Structured;
                    idsParam.TypeName = "<#= index.GetBulkTypeIdTable() #>";

                    connection.Open();
                    var reader = await command.ExecuteReaderAsync();
                    if (reader.HasRows)
                    {
                        while (reader.Read())
                        {
                            var data = Parse<#= Record #>DataModel(reader);
                            <#= RecordCamel #>Data.Add(data);
                        }

                        // consume any trailing pieces
                        while (reader.NextResult()) {}
                    }
                }
            }

            return <#= RecordCamel #>Data;
        }

<#
    }
#>
<#
    // Generate the Insert method if configured
    if (Table.Config.Insert)
    {
#>
        /// <summary>Inserts the given <#= Record #> data model into the <#= Record #> table.</summary>
        /// <param name="<#= RecordCamel #>Data">The <#= RecordLower #> data to insert.</param>
        /// <returns>The ID of the inserted <#= Record #> record if a primary key exists, otherwise, -1.</returns>
        public async Task<int> Insert(<#= Record #>DataModel <#= RecordCamel #>Data)
        {
            if (<#= RecordCamel #>Data == null)
            {
                throw new ArgumentNullException(nameof(<#= RecordCamel #>Data));
            }

            if (string.IsNullOrWhiteSpace(this.ConnectionString))
            {
                throw new InvalidOperationException("Connection String is null.  Insert operation cannot be performed.");
            }
            <#
            if (Table.HasPrimaryKey && PrimaryKey.IsIdentity)
            {
            #>

            if (<#= RecordCamel #>Data.<#= PrimaryKey.FieldName #> > 0)
            {
                throw new InvalidOperationException("Unable to insert <#= Record #> Data that already has a <#= PrimaryKey.FieldName #>.");
            }
            <#
            }
            #>

            var newId = -1;
            using (var connection = new SqlConnection(this.ConnectionString))
            {
                var procName = "[<#= Table.Schema #>].[<#= Table.GetInsertProcName() #>]";
                using (var command = new SqlCommand(procName))
                {
                    Log.LogInformation("Invoking Stored Procedure {0}.", procName);
                    command.CommandType = CommandType.StoredProcedure;
                    command.Connection = connection;
                    <#= GenerateInsertProcParams() #>

                    connection.Open();
                    var reader = await command.ExecuteReaderAsync();
                    if (reader.HasRows)
                    {
                        while (reader.Read())
                        {
                            <# if (Table.HasPrimaryKey) { #>
                            newId = (int)reader["<#= PrimaryKey.FieldName #>"];
                            <# } #>
                        }

                        // consume any trailing pieces
                        while (reader.NextResult()) {}
                    }
                }
            }

            return newId;
        }

<#
    }
#>
<#
    // Generate the Update method if configured
    if (Table.Config.Update)
    {
#>
        /// <summary>Updates the given <#= Record #> data model in the <#= Record #> table.</summary>
        /// <param name="<#= RecordCamel #>Data">The <#= RecordLower #> data to update.</param>
        /// <returns>The number of records affected by the update.</returns>
        public async Task<int> Update(<#= Record #>DataModel <#= RecordCamel #>Data)
        {
            if (<#= RecordCamel #>Data == null)
            {
                throw new ArgumentNullException(nameof(<#= RecordCamel #>Data));
            }

            if (string.IsNullOrWhiteSpace(this.ConnectionString))
            {
                throw new InvalidOperationException("Connection String is null.  Insert operation cannot be performed.");
            }

            if (<#= RecordCamel #>Data.<#=PrimaryKey.FieldName #> <= 0)
            {
                throw new InvalidOperationException("A valid <#=PrimaryKey.FieldName #> must be provided to update.");
            }

            var affectedRows = 0;
            using (var connection = new SqlConnection(this.ConnectionString))
            {
                var procName = "[<#= Table.Schema #>].[<#= Table.GetUpdateProcName() #>]";
                using (var command = new SqlCommand(procName))
                {
                    Log.LogInformation("Invoking Stored Procedure {0}.", procName);
                    command.CommandType = CommandType.StoredProcedure;
                    command.Connection = connection;
                    <#= GenerateUpdateProcParams() #>

                    connection.Open();
                    affectedRows = await command.ExecuteNonQueryAsync();
                }
            }

            return affectedRows;
        }

<#
    }
#>
<#
    // Generate the Delete method if configured
    if (Table.Config.Delete)
    {
#>
        /// <summary>Deletes record with the given <#= PrimaryKey.FieldName #> from the <#= Table.TableName #> table.</summary>
        /// <param name="<#= PrimaryKey.GetCodeParamName() #>">The <#= PrimaryKey.FieldName #>.</param>
        public async Task<int> Delete(int <#= PrimaryKey.GetCodeParamName() #>)
        {
            if (<#=PrimaryKey.GetCodeParamName() #> <= 0)
            {
                throw new InvalidOperationException("A valid <#=PrimaryKey.FieldName #> must be provided to delete.");
            }

            var affectedRows = 0;
            using (var connection = new SqlConnection(this.ConnectionString))
            {
                var procName = "[<#= Table.Schema #>].[<#= Table.GetDeleteProcName() #>]";
                using (var command = new SqlCommand(procName))
                {
                    Log.LogInformation("Invoking Stored Procedure {0}.", procName);
                    command.CommandType = CommandType.StoredProcedure;
                    command.Connection = connection;
                    command.Parameters.AddWithValue("<#= PrimaryKey.GetParamName() #>", <#= PrimaryKey.GetCodeParamName() #>);

                    connection.Open();
                    affectedRows = await command.ExecuteNonQueryAsync();
                }
            }

            return affectedRows;
        }

        /// <summary>Deletes the records with the given <#= PrimaryKey.FieldName #>s from the <#= Table.TableName #> table.</summary>
        /// <param name="<#= PrimaryKey.GetCodeParamName() #>s">The <#= PrimaryKey.FieldName #>s.</param>
        public async Task<int> Delete(IEnumerable<int> <#= PrimaryKey.GetCodeParamName() #>s)
        {
            if (<#= PrimaryKey.GetCodeParamName() #>s == null)
            {
                throw new ArgumentNullException(nameof(<#= PrimaryKey.GetCodeParamName() #>s));
            }

            if (!<#= PrimaryKey.GetCodeParamName() #>s.Any())
            {
                throw new ArgumentException("At least one <#= PrimaryKey.FieldName #> must be provided to delete.", nameof(<#= PrimaryKey.GetCodeParamName() #>s));
            }

            if (<#= PrimaryKey.GetCodeParamName() #>s.Any(i => i <= 0))
            {
                throw new InvalidOperationException("All <#=PrimaryKey.FieldName #>s must be valid to delete.");
            }

            // Create an in-memory datatable with the primary key values
            var idDataTable = new DataTable();
            idDataTable.Columns.Add(new DataColumn("<#= PrimaryKey.FieldName #>"));
            for (var i = 0; i < <#= PrimaryKey.GetCodeParamName() #>s.Count(); i++)
            {
                idDataTable.Rows.Add(<#= PrimaryKey.GetCodeParamName() #>s.ElementAt(i));
            }

            var affectedRows = 0;
            using (var connection = new SqlConnection(this.ConnectionString))
            {
                var procName = "[<#= Table.Schema #>].[<#= Table.GetDeleteBulkProcName() #>]";
                using (var command = new SqlCommand(procName))
                {
                    Log.LogInformation("Invoking Stored Procedure {0}.", procName);
                    command.CommandType = CommandType.StoredProcedure;
                    command.Connection = connection;

                    // Create the Stored Procedure Parameter and set to the Type table
                    var idsParam = command.Parameters.AddWithValue("<#= PrimaryKey.GetParamName() #>s", idDataTable);
                    idsParam.SqlDbType = SqlDbType.Structured;
                    idsParam.TypeName = "<#= PrimaryKeyIndex.GetBulkTypeIdTable() #>";

                    connection.Open();
                    affectedRows = await command.ExecuteNonQueryAsync();
                }
            }

            return affectedRows;
        }

<#
    }
#>
        /// <summary>Parses the <#= Record #> data model out of the reader.</summary>
        /// <param name="reader">The reader.</param>
        /// <returns>Populated <#= Record #> Data Model</returns>
        private <#= Record #>DataModel Parse<#= Record #>DataModel(IDataReader reader)
        {
            var data = new <#= Record #>DataModel();
            <#= GenerateReadFields() #>
            return data;
        }
    }
}
