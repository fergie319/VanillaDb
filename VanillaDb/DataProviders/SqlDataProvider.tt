<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="VanillaDb" #>
<#@ import namespace="VanillaDb.Models" #>
// <copyright file="<#= GenerateName() #>.cs" company="MMF Software Developers Inc.">
// Copyright (c) MMF Software Developers Inc.. All rights reserved.
// </copyright>

namespace <#= Record #>Service.DataProviders
{
    using System;
    using System.Collections.Generic;
    using System.Data;
    using System.Data.SqlClient;
    using System.Linq;

    /// <summary>SQL implementation of data provider interface for <#= Record #> data.</summary>
    /// <seealso cref="<#= Record #>Service.DataProviders.I<#= Record #>DataProvider" />
    public partial class <#= GenerateName() #> : I<#= Record #>DataProvider
    {
        /// <summary>Initializes a new instance of the <see cref="<#= GenerateName() #>"/> class.</summary>
        /// <param name="connectionString">The connection string.</param>
        public <#= GenerateName() #>(string connectionString) // TODO: Add Logger and log statements
        {
            this.ConnectionString = connectionString;
        }

        /// <summary>Gets or sets the connection string.</summary>
        /// <value>The connection string.</value>
        private string ConnectionString { get; set; }

<#
    // Generate the GetBy-Index and GetBy-Index-Bulk methods for each index
    foreach (IndexModel index in Indexes)
    {
#>
        /// <summary>Gets the data for the <#= Record #> with the given <#= index.ReadableFields() #>.</summary>
        <#= index.GetByIndexParamsXmlComments() #>
        /// <returns><#= Record #> Data Model or null if not found</returns>
        public <#= index.GetByIndexReturnType() #> <#= index.GetByIndexMethodName() #>(<#= index.GetByIndexMethodParams() #>)
        {
<#
        foreach (FieldModel field in index.Fields)
        {
#>
            if (string.IsNullOrWhiteSpace(<#= field.FieldName.ToCamelCase() #>))
            {
                throw new ArgumentNullException(nameof(<#= field.FieldName.ToCamelCase() #>));
            }
<#
        }
#>

            <#= Record #>DataModel <#= RecordCamel #>Data = null;
            using (var connection = new SqlConnection(this.ConnectionString))
            {
                using (var command = new SqlCommand("<#= GenerateGetByIndexStoredProcName(index) #>"))
                {
                    command.CommandType = CommandType.StoredProcedure;
                    command.Connection = connection;
                    <#= GenerateGetByIndexAddParametersCode(index.Fields) #>

                    connection.Open();
                    var reader = command.ExecuteReader();
                    if (reader.HasRows)
                    {
                        while (reader.Read())
                        {
                            <#= RecordCamel #>Data = Parse<#= Record #>DataModel(reader);
                        }
                    }
                }
            }

            return <#= RecordCamel #>Data;
        }
        <#
            // Hey Future Matt!  It's-a-me, Past Matt.  You are probably here trying to
            // figure out how to add Get-By-Index-Bulk support for a multi-field index.
            // I just thought I'd let you know that you need to generate a custom type or
            // make use of Tuples (yuck!) to do this.  Then a user would pass in an enumerable
            // of these objects all with unique pairings of the fields in the index.
        #>

        /// <summary>Gets the data for the <#= Record #>(s) with the given collection of <#= index.ReadableFields() #>.</summary>
        <#= GenerateGetByIndexBulkParamsXmlComments(index.Fields) #>
        /// <returns><#= Record #> Data Model or null if not found.</returns>
        public IEnumerable<<#= Record #>DataModel> <#= index.GetByIndexMethodName() #>(<#= GenerateGetByIndexBulkMethodParams(index.Fields) #>)
        {
<#
        foreach (FieldModel field in index.Fields)
        {
#>
            if (<#= field.FieldName.ToCamelCase() #>s == null || !<#= field.FieldName.ToCamelCase() #>.Any())
            {
                throw new ArgumentNullException(nameof(<#= field.FieldName.ToCamelCase() #>));
            }
<#
        }
#>

            // Create an in-memory datatable with all of the field values
            var idDataTable = new DataTable();
            <#= GenerateInMemoryDataColumns(index.Fields) #>
            for (var i = 0; i < <#= index.Fields.ElementAt(0).FieldName.ToCamelCase() #>s.Count(); i++)
            {
                <#= GenerateInMemoryRowCreation(index.Fields) #>
            }

            var <#= RecordCamel #>Data = new List<<#= Record #>DataModel>();
            using (var connection = new SqlConnection(this.ConnectionString))
            {
                using (var command = new SqlCommand("<#= GenerateGetByIndexBulkStoredProcName(index) #>"))
                {
                    command.CommandType = CommandType.StoredProcedure;
                    command.Connection = connection;

                    // Create the Stored Procedure Parameter and set to Type_IdTable
                    var idsParam = command.Parameters.AddWithValue("<#= GenerateBulkProcParameter(index) #>", idDataTable);
                    idsParam.SqlDbType = SqlDbType.Structured;
                    idsParam.TypeName = "<#= GenerateBulkTypeIdTable(index) #>";

                    connection.Open();
                    var reader = command.ExecuteReader();
                    if (reader.HasRows)
                    {
                        while (reader.Read())
                        {
                            var data = Parse<#= Record #>DataModel(reader);
                            <#= RecordCamel #>Data.Add(data);
                        }
                    }
                }
            }

            return <#= RecordCamel #>Data;
        }

<#
    }
#>
        /// <summary>Inserts the given <#= Record #> data model into the <#= Record #> table.</summary>
        /// <param name="<#= RecordCamel #>Data">The <#= RecordLower #> data to insert.</param>
        /// <returns>The ID of the inserted <#= Record #> record.</returns>
        public int Insert(<#= Record #>DataModel <#= RecordCamel #>Data)
        {
            if (<#= RecordCamel #>Data == null)
            {
                throw new ArgumentNullException(nameof(<#= RecordCamel #>Data));
            }

            if (string.IsNullOrWhiteSpace(this.ConnectionString))
            {
                throw new InvalidOperationException("Connection String is null.  Insert operation cannot be performed.");
            }

            if (<#= RecordCamel #>Data.<#= PrimaryKey #> > 0)
            {
                throw new InvalidOperationException("Unable to insert <#= Record #> Data that already has a <#= PrimaryKey #>.");
            }

            var <#= PrimaryKey.ToCamelCase() #> = -1;
            using (var connection = new SqlConnection(this.ConnectionString))
            {
                using (var command = new SqlCommand("<#= GenerateInsertProcName() #>"))
                {
                    command.CommandType = CommandType.StoredProcedure;
                    command.Connection = connection;
                    <#= GenerateInsertProcParams() #>

                    connection.Open();
                    var reader = command.ExecuteReader();
                    if (reader.HasRows)
                    {
                        while (reader.Read())
                        {
                            <#= PrimaryKey.ToCamelCase() #> = (int)reader["<#= PrimaryKey #>"];
                        }
                    }
                }
            }

            return <#= PrimaryKey.ToCamelCase() #>;
        }

        /// <summary>Parses the <#= Record #> data model out of the reader.</summary>
        /// <param name="reader">The reader.</param>
        /// <returns>Populated <#= Record #> Data Model</returns>
        private <#= Record #>DataModel Parse<#= Record #>DataModel(IDataReader reader)
        {
            var data = new <#= Record #>DataModel();
            <#= GenerateReadFields() #>
            return data;
        }
    }
}
